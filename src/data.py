import os
import sys

from elasticsearch.exceptions import NotFoundError
sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))

from util import tools
from configs.config import ES_SERVER_URL
from elasticsearch import Elasticsearch
from elasticsearch_dsl import Search, Q, A

class Field:
    """Define fields for data in an index"""

    def __init__(self, name, type=None, default=None):
        self.name = name
        self.type = type or 'str'
        self.default = default
    
    def __str__(self):
        return f'<{self.__class__.__name__}> \n field_name={self.name} \n field_type={self.type}'

class Data:
    """
    Data Representation.
       ES ↓
        - Index ↓
         - Field ↓
          - url
          - fav_count
          - milvus_id
          ...
         - Field ↓
          - name
          - url
          - ...
        - Index ↓
         - Field
         - Field 
         - Field
        - Index ↓
         - Field
         - Field
    """

    #Default fields that should exist within every index
    fields = [
        #_id fields generated by ES for every document
        Field(name='id'),
        Field(name='created', type='date'),
        Field(name='modified', type='date'),
        Field(name='deleted', type='bool', default=False)
    ]

    #Should be setted in the subclass in search
    index = None
    def __init__(self, id=None):
        if id:
            self.load(id)
    
    #load data
    def load(self, id):
        es_client = Elasticsearch(hosts=[ES_SERVER_URL])

        try: 
            item = es_client.get(index=self.index, id=id)
            print(f'{self.__class__.__name__} ("{self.index}") getting {id}')
        except NotFoundError:
            item = None
        
        if not item:
            raise FileNotFoundError(f'{self.__class__.__name__} '
                        f'<{id}> not found')
        
        self.id = item['_id']
        return self
    
    def field_list(self, exclude=None):
        """Save all current fields in Data and subclass in a field list"""

        exclude = exclude or []
        
        fields = Data.fields + self.fields
        return [field for field in fields if field.name not in exclude]

    def field_dict(self, exclude=None):
        """Upack obj var as key value pairs"""

        exclude = exclude or []
        
        return {key: tools.parse_value(value)
                for key, value in vars(self).items()
                if key not in exclude and
                key in [field.name for field in self.field_list()]}
    
    def search(self, filter=None, query=None, sort=None, page_size=10, 
               page=1, track_total_hits=None, aggs=None):
        """Send search/aggs query to ES, return a SearchRequestResponse
           Defaults to just send a match query, if there are no query specified
           Check https://elasticsearch-dsl.readthedocs.io/en/latest/search_dsl.html#the-search-object for refrence
        """

        """
        Example Call: 
        aggs = {
            "bucket": "hashtags_count",
            "agg_type": "terms",
            "field": "hashtags.keyword"
            "agg_size": "10"
        }
        twitter_data.search({"hashtags":"photography"}, aggs=aggs)

        above is searching hashtags field matching with photography, also doing
        an analysis of the total number of all different hashtags for doc that contains the hashtag photography
        """

        """
        We could also feed search with a specific query
        Example Call:
        query = {
            "range": {
                "likes": {
                    "gte": 10,
                    "lte": 20,
                }
            }
        }
        twitter_data.search(query=query)
        """

        srch = Search(index=self.index)
        es_client = Elasticsearch(hosts=[ES_SERVER_URL],timeout=30, 
        max_retries=10, retry_on_timeout=True)
        srch = srch.using(es_client)
        data = []

        filter = filter or {}
        track_total_hits = track_total_hits or False

        for key, value in {**filter}.items():
            if value is None:
                continue
            srch = srch.query('match', **{key: value})

        if query:
            srch = srch.query(Q(query))
        if sort:
            srch = srch.sort(sort)

        srch = srch.query(~Q('match', deleted=True))
        srch = srch[((page-1)*page_size):(page*page_size)]
        srch.extra(track_total_hits=track_total_hits)

        if aggs:
            bucket = aggs["bucket"]
            agg_type = aggs["agg_type"]
            field = aggs["field"]
            agg_size = aggs["agg_size"]

            srch.aggs.bucket(bucket, A(agg_type, field=field, size=agg_size))

        res = srch.execute()
        hits = res.hits
        hits_count = res.hits.total
        resp_status = "Failed"
        if res.success():
            resp_status = "Success"
        time_took = res.took

        for hit in hits:
            data_dict = hit.to_dict()
            data_dict.update({"score": hit.meta.score})
            data.append(data_dict)

        result = {
            "status": resp_status,
            "count": hits_count,
            "took": time_took,
            "data": data
        }

        if 'aggregations' in res:
            result.update({"aggs":res.aggregations.to_dict()})

        return result

    def save(self):
        """Save changes to ES if index exists, if not create new index"""

        es_client = Elasticsearch(hosts=[ES_SERVER_URL])

        cur_time = tools.get_local_time('America/Los_Angeles')
        self.modified = cur_time
        if not hasattr(self, 'created'):
            self.created = cur_time
        
        for field in self.field_list():
            if (field.default is not None
                and (not hasattr(self, field.name) or
                     getattr(self, field.name) is None)):
                setattr(self, field.name, field.default)
        
        body = self.field_dict(exclude='id')

        kwargs = {
            'index': self.index,
            'body': body
        }

        if hasattr(self, 'id'):
            kwargs['id'] = self.id

        resp = es_client.index(**kwargs)
        self.id = resp.get('_id')
        return self

    def delete(self):
        """Set delete to true for this data"""
        
        self.deleted = True
        self.save()